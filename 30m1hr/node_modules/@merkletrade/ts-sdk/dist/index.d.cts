import * as tsa from 'ts-arithmetic';
import * as tf from 'type-fest';
import { Simplify } from 'type-fest';
import * as _aptos_labs_ts_sdk from '@aptos-labs/ts-sdk';
import { UserTransactionResponse, AccountAddressInput, EntryFunctionABI, AptosConfig } from '@aptos-labs/ts-sdk';

type MerkleConfig = {
    baseURL: string;
    wsURL: string;
    fetchFn?: typeof fetch;
    WebSocketCtor?: typeof WebSocket;
};
declare namespace MerkleConfig {
    const MAINNET: {
        baseURL: string;
        wsURL: string;
    };
    const TESTNET: {
        baseURL: string;
        wsURL: string;
    };
}

declare const __decimal: unique symbol;
type Decimal<N extends Range | unknown> = bigint & {
    readonly [__decimal]: N;
};
declare namespace Decimal {
    type Of<T> = T extends Decimal<infer N> ? N : unknown;
}
type Range = tf.IntRange<0, 50>;
declare namespace Range {
    type UnsafeAdd<A, B> = A extends number ? B extends number ? tf.Sum<A, B> extends Range ? tf.Sum<A, B> : unknown : unknown : unknown;
    type UnsafeSub<A, B> = A extends number ? B extends number ? tf.Sum<A, tsa.Negate<B>> extends Range ? tf.Sum<A, tsa.Negate<B>> : unknown : unknown : unknown;
}
/** operations */
declare function dec<N extends Range>(n: bigint): Decimal<N>;
/** equivalent to `dec<0>` */
declare function dec0(n: bigint): Decimal<0>;
declare function undec<N extends Range>(n: Decimal<N>): bigint;
declare function one<N extends Range>(decimals: N, isPositive?: boolean): Decimal<N>;
declare function zero<N extends Range>(): Decimal<N>;
declare function sign<N extends Range>(n: Decimal<N>): Decimal<N>;
declare function neg<N extends Range>(n: Decimal<N>): Decimal<N>;
declare function shift<N extends Range, const S extends Range | tsa.Negate<Range>>(n: Decimal<N>, shiftBy: S): Decimal<Range.UnsafeAdd<N, S>>;
declare function add<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): Decimal<N>;
declare function sub<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): Decimal<N>;
declare function mul<A extends Range, B extends Range>(a: Decimal<A>, b: Decimal<B>): Decimal<Range.UnsafeAdd<A, B>>;
declare function div<A extends Range, B extends Range>(a: Decimal<A>, b: Decimal<B>): Decimal<Range.UnsafeSub<A, B>>;
declare function gt<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): boolean;
declare function gte<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): boolean;
declare function lt<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): boolean;
declare function lte<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): boolean;
declare function min<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): Decimal<N>;
declare function max<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): Decimal<N>;
declare function abs<N extends Range>(n: Decimal<N>): Decimal<N>;
declare function avg<N extends Range>(a: Decimal<N>, b: Decimal<NoInfer<N>>): Decimal<N>;
declare function fromNumber<N extends Range>(n: number, decimals: N): Decimal<N>;
declare function toNumber<N extends Range>(n: Decimal<N>, decimals: NoInfer<N>): number;
declare function toNumber<N>(n: Decimal<N extends Range ? `decimals must be ${N}` : N>, // disallow Range (only for unknown)
decimals: number): number;
declare function toFixed<N extends Range>(n: Decimal<N>, decimals: NoInfer<N>): string;
declare function toFixed<N>(n: Decimal<N extends Range ? `decimals must be ${N}` : N>, // disallow Range (only for unknown)
decimals: number): string;

declare namespace Decimals {
    const COLLATERAL = 6;
    const PRICE = 10;
    const BPS = 4;
    const PRECISION = 6;
    const FUNDING_PRECISION = 8;
    type Collateral = Decimal<typeof Decimals.COLLATERAL>;
    type Price = Decimal<typeof Decimals.PRICE>;
    type Bps = Decimal<typeof Decimals.BPS>;
    type Precision = Decimal<typeof Decimals.PRECISION>;
    type FundingPrecision = Decimal<typeof Decimals.FUNDING_PRECISION>;
    type APT = Decimal<8>;
}
type Order = {
    version: number;
    timestamp: Date;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    orderId: number;
    /** @deprecated */ uid: number;
    user: Hex;
    sizeDelta: Decimals.Collateral;
    collateralDelta: Decimals.Collateral;
    price: Decimals.Price;
    isLong: boolean;
    isIncrease: boolean;
    isMarket: boolean;
    canExecuteAbovePrice: boolean;
    stopLossTriggerPrice: Decimals.Price;
    takeProfitTriggerPrice: Decimals.Price;
    createdTimestamp: number;
};
type Position = {
    version: number;
    timestamp: Date;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    isLong: boolean;
    user: Hex;
    uid: number;
    size: Decimals.Collateral;
    collateral: Decimals.Collateral;
    avgPrice: Decimals.Price;
    lastExecuteTimestamp: number;
    accRolloverFeePerCollateral: Decimals.FundingPrecision;
    /** cumulative funding rate per size */
    accFundingFeePerSize: Decimals.FundingPrecision;
    stopLossTriggerPrice: Decimals.Price;
    takeProfitTriggerPrice: Decimals.Price;
};
type PairInfo = Simplify<{
    version: number;
    timestamp: Date;
} & PairInfo.V1 & PairInfo.V2>;
declare namespace PairInfo {
    type V1 = {
        versionV1: number;
        timestampV1: Date;
        pairType: MoveStructId;
        collateralType: MoveStructId;
        paused: boolean;
        minLeverage: Decimals.Precision;
        maxLeverage: Decimals.Precision;
        makerFee: Decimals.Collateral;
        takerFee: Decimals.Collateral;
        rolloverFeePerTimestamp: Decimals.FundingPrecision;
        skewFactor: Decimals.Collateral;
        maxFundingVelocity: Decimals.FundingPrecision;
        maxOpenInterest: Decimals.Collateral;
        executeTimeLimit: number;
        liquidateThreshold: Decimals.Bps;
        maximumProfit: Decimals.Bps;
        minimumOrderCollateral: Decimals.Collateral;
        minimumPositionCollateral: Decimals.Collateral;
        minimumPositionSize: Decimals.Collateral;
        maximumPositionCollateral: Decimals.Collateral;
        executionFee: Decimals.APT;
    };
    type V2 = {
        versionV2: number;
        timestampV2: Date;
        pairType: MoveStructId;
        collateralType: MoveStructId;
        maximumSkewLimit: Decimals.Collateral;
        cooldownPeriodSecond: number;
    };
    const mergeVersions: (v1: V1, v2: V2) => PairInfo;
}
type PairState = {
    version: number;
    timestamp: Date;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    nextOrderId: number;
    longOpenInterest: Decimals.Collateral;
    shortOpenInterest: Decimals.Collateral;
    fundingRate: Decimals.FundingPrecision;
    accFundingFeePerSize: Decimals.FundingPrecision;
    accRolloverFeePerCollateral: Decimals.FundingPrecision;
    lastAccrueTimestamp: number;
    orders: TableHandle;
    longPositions: TableHandle;
    shortPositions: TableHandle;
};
type PlaceOrderEvent = {
    version: number;
    timestamp: Date;
    eventIndex: number;
    /** @deprecated always 0 */ uid: number;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    user: Hex;
    orderId: number;
    sizeDelta: Decimals.Collateral;
    collateralDelta: Decimals.Collateral;
    price: Decimals.Price;
    isLong: boolean;
    isIncrease: boolean;
    isMarket: boolean;
};
type CancelOrderEvent = {
    version: number;
    timestamp: Date;
    eventIndex: number;
    uid: number;
    eventType: CancelOrderEvent.EventType;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    user: Hex;
    orderId: number;
    sizeDelta: Decimals.Collateral;
    collateralDelta: Decimals.Collateral;
    price: Decimals.Price;
    isLong: boolean;
    isIncrease: boolean;
    isMarket: boolean;
};
declare namespace CancelOrderEvent {
    const eventTypes: readonly ["cancel_order_by_user", "cancel_order_max_leverage", "cancel_order_under_min_leverage", "cancel_order_unexecutable_market_order", "cancel_order_not_enough_collateral", "cancel_order_not_enough_size", "cancel_order_expired", "cancel_order_over_max_interest", "cancel_order_over_max_collateral", "cancel_order_over_max_skew_limit"];
    type EventType = (typeof eventTypes)[number];
}
type PositionEvent = {
    version: number;
    timestamp: Date;
    eventIndex: number;
    uid: number;
    eventType: PositionEvent.EventType;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    user: Hex;
    orderId: number;
    isLong: boolean;
    price: Decimals.Price;
    originalSize: Decimals.Collateral;
    sizeDelta: Decimals.Collateral;
    originalCollateral: Decimals.Collateral;
    collateralDelta: Decimals.Collateral;
    isIncrease: boolean;
    isPartial: boolean;
    pnlWithoutFee: Decimals.Collateral;
    isProfit: boolean;
    entryExitFee: Decimals.Collateral;
    fundingFee: Decimals.Collateral;
    rolloverFee: Decimals.Collateral;
    longOpenInterest: Decimals.Collateral;
    shortOpenInterest: Decimals.Collateral;
};
declare namespace PositionEvent {
    const eventTypes: string[];
    type EventType = (typeof eventTypes)[number];
}
type UpdateTPSLEvent = {
    version: number;
    timestamp: Date;
    eventIndex: number;
    uid: number;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    user: Hex;
    isLong: boolean;
    takeProfitTriggerPrice: Decimals.Price;
    stopLossTriggerPrice: Decimals.Price;
};

type RawPairInfoResponse = {
    collateralType: MoveStructId;
    pairType: MoveStructId;
    executeTimeLimit: number;
    executionFee: string;
    liquidateThreshold: string;
    makerFee: string;
    maxFundingVelocity: string;
    maxLeverage: string;
    maxOpenInterest: string;
    maximumPositionCollateral: string;
    maximumProfit: string;
    minLeverage: string;
    minimumOrderCollateral: string;
    minimumPositionCollateral: string;
    minimumPositionSize: string;
    paused: boolean;
    rolloverFeePerTimestamp: string;
    skewFactor: string;
    takerFee: string;
    cooldownPeriodSecond: number;
    maximumSkewLimit: string;
    timestamp: string;
    timestampV1: string;
    timestampV2: string;
    version: number;
    versionV1: number;
    versionV2: number;
};
declare namespace RawPairInfoResponse {
    function to(raw: RawPairInfoResponse): PairInfo;
}
type RawPairStateResponse = {
    version: number;
    timestamp: string;
    collateralType: MoveStructId;
    pairType: MoveStructId;
    nextOrderId: number;
    longOpenInterest: string;
    shortOpenInterest: string;
    fundingRate: string;
    accFundingFeePerSize: string;
    accRolloverFeePerCollateral: string;
    lastAccrueTimestamp: number;
    orders: TableHandle;
    longPositions: TableHandle;
    shortPositions: TableHandle;
};
declare namespace RawPairStateResponse {
    function to(raw: RawPairStateResponse): PairState;
}
type RawTradeHistory = {
    version: number;
    type: MoveStructId;
    orderId: string;
    uid: string;
    address: Hex;
    eventType: PositionEvent.EventType;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    isLong: boolean;
    leverage: string;
    price: string;
    originalSize: string;
    sizeDelta: string;
    originalCollateral: string;
    collateralDelta: string;
    isIncrease: boolean;
    pnlWithoutFee: string;
    entryExitFee: string;
    fundingFee: string;
    rolloverFee: string;
    longOpenInterest: string;
    shortOpenInterest: string;
    ts: string;
};
declare namespace RawTradeHistory {
    function to(raw: RawTradeHistory): TradeHistory;
}
type TradeHistory = Omit<RawTradeHistory, "version" | "orderId" | "uid" | "ts"> & {
    version: number;
    orderId: number;
    uid: number;
    ts: Date;
};
type RawPosition = {
    version: number;
    timestamp: string;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    isLong: boolean;
    user: Hex;
    uid: number;
    size: string;
    collateral: string;
    avgPrice: string;
    lastExecuteTimestamp: number;
    accRolloverFeePerCollateral: string;
    accFundingFeePerSize: string;
    stopLossTriggerPrice: string;
    takeProfitTriggerPrice: string;
};
declare namespace RawPosition {
    function to(raw: RawPosition): Position;
}
type RawOrder = {
    version: number;
    timestamp: string;
    pairType: MoveStructId;
    collateralType: MoveStructId;
    orderId: number;
    /** @deprecated */
    uid: number;
    user: Hex;
    sizeDelta: string;
    collateralDelta: string;
    price: string;
    isLong: boolean;
    isIncrease: boolean;
    isMarket: boolean;
    canExecuteAbovePrice: boolean;
    stopLossTriggerPrice: string;
    takeProfitTriggerPrice: string;
    createdTimestamp: number;
};
declare namespace RawOrder {
    function to(raw: RawOrder): Order;
}

type RawSummaryResponse = {
    hostAddress: Hex;
    lzBridgeAddress: Hex;
    collectionIds: {
        gear: Hex;
        userNameTicket: Hex;
    };
    liquidswapLp: Hex;
    liquidswapV05: Hex;
    merkleBridgeTools: Hex;
    multisigUtils: Hex;
    coins: SummaryCoin[];
    pairs: RawSummaryPair[];
    gasEstimates: {
        deprioritized: number;
        regular: number;
        prioritized: number;
    };
    prices: SummaryPrice[];
};
declare namespace RawSummaryResponse {
    function to(raw: RawSummaryResponse): Summary;
}
type Summary = Omit<RawSummaryResponse, "pairs"> & {
    pairs: SummaryPair[];
};
type SummaryCoin = {
    id: string;
    type: "fungible-asset" | "coin-store";
    coinType?: MoveStructId;
    assetType?: Hex;
    name: string;
    symbol: string;
    decimals: number;
};
type RawSummaryPair = {
    id: string;
    name: string;
    type: "crypto" | "forex" | "stable" | "commodity";
    pairType: MoveStructId;
    symbol: string;
    symbolLong: string;
    decimals: number;
    isMarketOpen: boolean;
    listingDate?: string;
    visible?: boolean;
};
declare namespace RawSummaryPair {
    function to(raw: RawSummaryPair): SummaryPair;
}
type SummaryPair = Omit<RawSummaryPair, "listingDate"> & {
    listingDate?: Date;
};
type SummaryPrice = {
    id: string;
    price?: number;
    price24ago?: number;
};

type RawFeepayerResponse = {
    tx: UserTransactionResponse;
    txHash: string;
    rateLimitRemaining: number;
} | {
    error: string;
};
type FeepayerResponse = RawFeepayerResponse;

type PriceFeed = {
    pair: string;
    price: string;
    ts: number;
};
type AccountFeed = (PositionEvent | CancelOrderEvent | PlaceOrderEvent) & {
    eventKey: "PlaceOrderEvent" | "CancelOrderEvent" | "PositionEvent";
};

type Hex = `0x${string}`;
type MoveStructId = `0x${string}::${string}::${string}`;
type TableHandle = {
    handle: Hex;
};
type SimpleMap<K extends string, V> = Partial<{
    [k in K]: V;
}>;
type Coin<N = unknown> = {
    value: Decimal<N>;
};
declare namespace AptosObject {
    type TransferRef = {
        self: Hex;
    };
    type ExtendRef = {
        self: Hex;
    };
    type DeleteRef = {
        self: Hex;
    };
}
declare namespace Token {
    type MutatorRef = {
        self: Hex;
    };
    type BurnRef = {
        inner: {
            vec: {
                self: Hex;
            }[];
        };
        self: {
            vec: [];
        };
    };
}
declare namespace Royalty {
    type MutatorRef = {
        inner: {
            self: Hex;
        };
    };
}
declare namespace Account {
    type SignerCapability = {
        account: Hex;
    };
}
declare namespace Collection {
    type MutatorRef = {
        self: Hex;
    };
}

/**
 * @description Get summary
 * @returns Summary
 */
declare function getSummary(args: {
    merkleConfig: MerkleConfig;
}): Promise<Summary>;
/**
 * @description Get pair info
 * @param pairId - Pair ID example: `BTC_USD`
 * @returns Pair info
 */
declare function getPairInfo(args: {
    merkleConfig: MerkleConfig;
    pairId: string;
}): Promise<PairInfo>;
/**
 * @description Get all pair info
 * @returns All pair info
 */
declare function getAllPairInfos(args: {
    merkleConfig: MerkleConfig;
}): Promise<PairInfo[]>;
/**
 * @description Get pair state
 * @param pairId - Pair ID example: `BTC_USD`
 * @returns Pair state
 */
declare function getPairState(args: {
    merkleConfig: MerkleConfig;
    pairId: string;
}): Promise<PairState>;
/**
 * @description Get all pair state
 * @returns All pair state
 */
declare function getAllPairStates(args: {
    merkleConfig: MerkleConfig;
}): Promise<PairState[]>;
/**
 * @description Get orders
 * @param address - Address
 * @returns Orders
 */
declare function getOrders(args: {
    merkleConfig: MerkleConfig;
    address: Hex;
}): Promise<Order[]>;
/**
 * @description Get positions
 * @param address - Address
 * @returns Positions
 */
declare function getPositions(args: {
    merkleConfig: MerkleConfig;
    address: Hex;
}): Promise<Position[]>;
/**
 * @description Get trading history
 * @param address - Address
 * @returns Trading history
 */
declare function getTradingHistory(args: {
    merkleConfig: MerkleConfig;
    address: Hex;
}): Promise<TradeHistory[]>;
/**
 * @description Post feepayer
 * @param txHex - Transaction
 * @param senderAuthenticator - Sender authenticator
 * @returns Feepayer response
 */
declare function postFeepayer(args: {
    merkleConfig: MerkleConfig;
    txHex: string;
    senderAuthenticator: string;
}): Promise<FeepayerResponse>;

type WSAPISessionConfig = {
    wsURL: string;
    WebSocketCtor?: new (url: string | URL, protocols?: string | string[]) => WebSocket;
};
declare class WSAPISession {
    private ws;
    private openPromise;
    private subscriptions;
    constructor(config: WSAPISessionConfig);
    connect(): Promise<void>;
    disconnect(): void;
    private handleMessage;
    private handleClose;
    subscribePriceFeed(pairId: string): AsyncIterable<PriceFeed>;
    subscribeAccountFeed(account: Hex): AsyncIterable<AccountFeed>;
    subscribe<T>(key: string): AsyncIterable<T>;
}

declare const PRICE_MAX: Decimals.Price;
declare const PRICE_MIN: Decimals.Price;
declare function placeMarketOrder(args: {
    summary: Summary;
    /** pair id or pair type */
    pair: string;
    userAddress: AccountAddressInput;
    sizeDelta: bigint;
    collateralDelta: bigint;
    slippage?: {
        markPrice: bigint;
        slippageBps: bigint;
    };
    isLong: boolean;
    isIncrease: boolean;
    stopLossTriggerPrice?: bigint;
    takeProfitTriggerPrice?: bigint;
    canExecuteAbovePrice?: boolean;
    referrer?: AccountAddressInput;
}): {
    function: `0x${string}::managed_trading::place_order_v3`;
    typeArguments: string[];
    functionArguments: (bigint | boolean | AccountAddressInput)[];
    abi: EntryFunctionABI;
};
declare function placeLimitOrder(args: {
    summary: Summary;
    /** pair id or pair type */
    pair: string;
    userAddress: AccountAddressInput;
    sizeDelta: bigint;
    collateralDelta: bigint;
    price: bigint;
    isLong: boolean;
    isIncrease: boolean;
    stopLossTriggerPrice?: bigint;
    takeProfitTriggerPrice?: bigint;
    canExecuteAbovePrice?: boolean;
    referrer?: AccountAddressInput;
}): {
    function: `0x${string}::managed_trading::place_order_v3`;
    typeArguments: string[];
    functionArguments: (bigint | boolean | AccountAddressInput)[];
    abi: EntryFunctionABI;
};
declare function cancelOrder(args: {
    summary: Summary;
    /** pair id or pair type */
    pair: string;
    userAddress: Hex;
    orderId: bigint;
}): {
    function: `0x${string}::managed_trading::cancel_order_v3`;
    typeArguments: string[];
    functionArguments: (bigint | `0x${string}`)[];
    abi: EntryFunctionABI;
};
declare function updateTPSL(args: {
    summary: Summary;
    /** pair id or pair type */
    pair: string;
    userAddress: AccountAddressInput;
    isLong: boolean;
    stopLossTriggerPrice: bigint;
    takeProfitTriggerPrice: bigint;
}): {
    function: `0x${string}::managed_trading::update_position_tp_sl_v3`;
    typeArguments: string[];
    functionArguments: (bigint | boolean | AccountAddressInput)[];
    abi: EntryFunctionABI;
};
declare function testnetFaucetUSDC(args: {
    summary: Summary;
    amount: bigint;
}): {
    function: `0x${string}::test_trading::faucet_native_usdc`;
    functionArguments: bigint[];
};

declare function getUsdcBalance(args: {
    aptosConfig: AptosConfig;
    summary: Summary;
    accountAddress: AccountAddressInput;
}): Promise<Decimals.Collateral>;

declare const PRECISION: Decimal<6>;
type Timestamp = bigint | Decimal<0>;
/** Calculates new `avgPrice` for increased position */
declare const calcNewPrice: ({ position: { avgPrice, size }, increaseOrder: { sizeDelta }, price, }: {
    position: Pick<Position, "avgPrice" | "size">;
    increaseOrder: Pick<Order, "sizeDelta">;
    price: Decimals.Price;
}) => Decimals.Price;
declare const calcPnlWithoutFee: ({ position: { avgPrice, isLong }, executePrice, decreaseOrder: { sizeDelta }, }: {
    position: Pick<Position, "avgPrice" | "isLong">;
    executePrice: Decimals.Price;
    decreaseOrder: Pick<Order, "sizeDelta">;
}) => Decimals.Collateral;
/**
 * Returns the estimated execute price for given order.
 * For current price, use `calcPriceInfo`
 * For price impact, use `calcPriceImpactInfo`
 **/
declare const calcPriceImpact: ({ pairInfo: { skewFactor }, pairState: { longOpenInterest, shortOpenInterest }, idxPrice, order: { sizeDelta, isLong, isIncrease }, }: {
    pairInfo: Pick<PairInfo, "skewFactor">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest">;
    idxPrice: Decimals.Price;
    order?: Pick<Order, "sizeDelta" | "isLong" | "isIncrease">;
}) => Decimals.Price;
declare const calcRolloverFee: ({ position: { collateral, accRolloverFeePerCollateral: acc }, currentAccRolloverFeePerCollateral: currentAcc, }: {
    position: Pick<Position, "collateral" | "accRolloverFeePerCollateral">;
    currentAccRolloverFeePerCollateral: Decimals.FundingPrecision;
}) => Decimals.Collateral;
declare const calcFundingRate: ({ pairInfo: { skewFactor, maxFundingVelocity }, pairState: { longOpenInterest, shortOpenInterest, fundingRate }, timeDeltaSec, }: {
    pairInfo: Pick<PairInfo, "skewFactor" | "maxFundingVelocity">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest" | "fundingRate">;
    timeDeltaSec: Timestamp;
}) => Decimals.FundingPrecision;
declare const calcAccFundingFeePerSize: ({ pairState: { fundingRate, accFundingFeePerSize }, currentFundingRate, timeDeltaSec, }: {
    pairState: Pick<PairState, "fundingRate" | "accFundingFeePerSize">;
    currentFundingRate: Decimals.FundingPrecision;
    timeDeltaSec: Timestamp;
}) => Decimals.FundingPrecision;
/**
 * NOTE: positive funding fee means the user pays funding fee.
 * Different from contract `calc_funding_fee`, which returns the funding fee the user receives.
 */
declare const calcFundingFee: ({ position: { size, isLong, accFundingFeePerSize: acc }, currentAccFundingFeePerSize: currentAcc, }: {
    position: Pick<Position, "size" | "isLong" | "accFundingFeePerSize">;
    currentAccFundingFeePerSize: Decimals.FundingPrecision;
}) => Decimals.Collateral;
declare const calcMakerTakerFee: ({ pairInfo: { makerFee: makerRate, takerFee: takerRate }, pairState: { longOpenInterest, shortOpenInterest }, order: { sizeDelta, isLong, isIncrease }, }: {
    pairInfo: Pick<PairInfo, "makerFee" | "takerFee">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest">;
    order: Pick<Order, "sizeDelta" | "isLong" | "isIncrease">;
}) => Decimals.Collateral;

type PriceImpactInfo = {
    price: Decimals.Price;
    priceImpact: Decimals.Price;
    priceImpactRatio: Decimals.Precision;
};
declare const calcPriceImpactInfo: ({ pairInfo, pairState, idxPrice, order, }: {
    pairInfo: Pick<PairInfo, "skewFactor">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest">;
    idxPrice: Decimals.Price;
    order?: Pick<Order, "sizeDelta" | "isLong" | "isIncrease">;
}) => PriceImpactInfo;
type FundingInfo = {
    currentFundingRate: Decimals.FundingPrecision;
    currentAccFundingFeePerSize: Decimals.FundingPrecision;
};
declare const calcFundingInfo: ({ pairInfo, pairState, timestampSec, }: {
    pairInfo: Pick<PairInfo, "skewFactor" | "maxFundingVelocity">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest" | "fundingRate" | "accFundingFeePerSize" | "lastAccrueTimestamp">;
    timestampSec: Timestamp;
}) => FundingInfo;
declare const calcAccRolloverFeePerCollateral: ({ pairInfo: { rolloverFeePerTimestamp }, pairState: { lastAccrueTimestamp, accRolloverFeePerCollateral }, timestampSec, }: {
    pairInfo: Pick<PairInfo, "rolloverFeePerTimestamp">;
    pairState: Pick<PairState, "lastAccrueTimestamp" | "accRolloverFeePerCollateral">;
    timestampSec: Timestamp;
}) => Decimals.FundingPrecision;
declare const calcExitFee: ({ pairInfo, pairState, position: { size, isLong }, }: {
    pairInfo: Pick<PairInfo, "makerFee" | "takerFee">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest">;
    position: Pick<Position, "size" | "isLong">;
}) => Decimals.Collateral;
type PositionFees = {
    total: Decimals.Collateral;
    exitFee: Decimals.Collateral;
    rolloverFee: Decimals.Collateral;
    fundingFee: Decimals.Collateral;
};
declare const calcPositionFees: ({ pairInfo, pairState, position, timestampSec, }: {
    pairInfo: Pick<PairInfo, "skewFactor" | "maxFundingVelocity" | "rolloverFeePerTimestamp" | "makerFee" | "takerFee">;
    pairState: Pick<PairState, "longOpenInterest" | "shortOpenInterest" | "fundingRate" | "accFundingFeePerSize" | "accRolloverFeePerCollateral" | "lastAccrueTimestamp">;
    position: Pick<Position, "size" | "collateral" | "isLong" | "avgPrice" | "accFundingFeePerSize" | "accRolloverFeePerCollateral">;
    timestampSec: Timestamp;
}) => PositionFees;
type PnlInfo = {
    pnl: Decimals.Collateral;
    pnlRate: Decimals.Collateral;
    pnlWithFee: Decimals.Collateral;
    pnlWithFeeRate: Decimals.Collateral;
};
declare const calcPnlInfo: ({ position: { size, collateral, isLong, avgPrice }, feesTotal, executePrice, }: {
    position: Pick<Position, "size" | "collateral" | "isLong" | "avgPrice">;
    feesTotal: Decimals.Collateral;
    executePrice: Decimals.Price;
}) => PnlInfo;
declare const calcEntryByPaySize: (pay: Decimals.Collateral, leverage: number, isLong: boolean, pairInfo: PairInfo, pairState: PairState) => {
    collateral: Decimals.Collateral;
    size: Decimals.Collateral;
    fee: Decimals.Collateral;
};
/**
 * Calculate the slippage applied price for orders
 *
 * @param markPrice - The mark price
 * @param isIncrease - Whether the order is an increase order
 * @param isLong - Whether the position is long
 * @param slippageBps - The slippage in basis points
 * @returns The slippage price
 */
declare const calcSlippagePrice: (markPrice: Decimals.Price, isIncrease: boolean, isLong: boolean, slippageBps: Decimals.Bps) => Decimals.Price;

type MerkleClientConfig = {
    merkleConfig: MerkleConfig;
    aptosConfig: AptosConfig;
    summary: Summary;
};
declare namespace MerkleClientConfig {
    const mainnet: (config?: Partial<MerkleClientConfig>) => Promise<{
        merkleConfig: {
            baseURL: string;
            wsURL: string;
        };
        aptosConfig: AptosConfig;
        summary: Summary;
    }>;
    const testnet: (config?: Partial<MerkleClientConfig>) => Promise<{
        merkleConfig: {
            baseURL: string;
            wsURL: string;
        };
        aptosConfig: AptosConfig;
        summary: Summary;
    }>;
}

declare class APIClient {
    readonly config: MerkleClientConfig;
    constructor(config: MerkleClientConfig);
    /**
     * @description Get summary
     * @returns Summary
     */
    getSummary(): Promise<Summary>;
    /**
     * @description Get pair info
     * @param pairId - Pair ID example: `BTC_USD`
     * @returns Pair info
     */
    getPairInfo(args: {
        pairId: string;
    }): Promise<PairInfo>;
    /**
     * @description Get all pair info
     * @returns All pair info
     */
    getAllPairInfos(): Promise<PairInfo[]>;
    /**
     * @description Get pair state
     * @param pairId - Pair ID example: `BTC_USD`
     * @returns Pair state
     */
    getPairState(args: {
        pairId: string;
    }): Promise<PairState>;
    /**
     * @description Get all pair state
     * @returns All pair state
     */
    getAllPairStates(): Promise<PairState[]>;
    /**
     * @description Get orders
     * @param address - Address
     * @returns Orders
     */
    getOrders(args: {
        address: Hex;
    }): Promise<Order[]>;
    /**
     * @description Get positions
     * @param address - Address
     * @returns Positions
     */
    getPositions(args: {
        address: Hex;
    }): Promise<Position[]>;
    /**
     * @description Get trading history
     * @param address - Address
     * @returns Trading history
     */
    getTradingHistory(args: {
        address: Hex;
    }): Promise<TradeHistory[]>;
    /**
     * @description Post feepayer
     * @param txHex - Transaction
     * @param senderAuthenticator - Sender authenticator
     * @returns Feepayer response
     */
    postFeepayer(args: {
        txHex: string;
        senderAuthenticator: string;
    }): Promise<FeepayerResponse>;
}

declare class WSAPIClient {
    readonly config: MerkleClientConfig;
    constructor(config: MerkleClientConfig);
    connectWsApi(config?: Partial<WSAPISessionConfig>): Promise<WSAPISession>;
}

declare class AptosHelpers {
    readonly config: MerkleClientConfig;
    constructor(config: MerkleClientConfig);
    getUsdcBalance(args: {
        accountAddress: AccountAddressInput;
    }): Promise<Decimals.Collateral>;
}

declare class MerklePayloadBuilder {
    readonly config: MerkleClientConfig;
    constructor(config: MerkleClientConfig);
    placeMarketOrder(args: {
        /** pair id or pair type */
        pair: string;
        userAddress: AccountAddressInput;
        sizeDelta: bigint;
        collateralDelta: bigint;
        slippage?: {
            markPrice: bigint;
            slippageBps: bigint;
        };
        isLong: boolean;
        isIncrease: boolean;
        stopLossTriggerPrice?: bigint;
        takeProfitTriggerPrice?: bigint;
        canExecuteAbovePrice?: boolean;
        referrer?: AccountAddressInput;
    }): {
        function: `0x${string}::managed_trading::place_order_v3`;
        typeArguments: string[];
        functionArguments: (bigint | boolean | AccountAddressInput)[];
        abi: _aptos_labs_ts_sdk.EntryFunctionABI;
    };
    placeLimitOrder(args: {
        /** pair id or pair type */
        pair: string;
        userAddress: AccountAddressInput;
        sizeDelta: bigint;
        collateralDelta: bigint;
        price: bigint;
        isLong: boolean;
        isIncrease: boolean;
        stopLossTriggerPrice?: bigint;
        takeProfitTriggerPrice?: bigint;
        canExecuteAbovePrice?: boolean;
        referrer?: AccountAddressInput;
    }): {
        function: `0x${string}::managed_trading::place_order_v3`;
        typeArguments: string[];
        functionArguments: (bigint | boolean | AccountAddressInput)[];
        abi: _aptos_labs_ts_sdk.EntryFunctionABI;
    };
    cancelOrder(args: {
        /** pair id or pair type */
        pair: string;
        userAddress: Hex;
        orderId: bigint;
    }): {
        function: `0x${string}::managed_trading::cancel_order_v3`;
        typeArguments: string[];
        functionArguments: (bigint | `0x${string}`)[];
        abi: _aptos_labs_ts_sdk.EntryFunctionABI;
    };
    updateTPSL(args: {
        /** pair id or pair type */
        pair: string;
        userAddress: AccountAddressInput;
        isLong: boolean;
        stopLossTriggerPrice: bigint;
        takeProfitTriggerPrice: bigint;
    }): {
        function: `0x${string}::managed_trading::update_position_tp_sl_v3`;
        typeArguments: string[];
        functionArguments: (bigint | boolean | AccountAddressInput)[];
        abi: _aptos_labs_ts_sdk.EntryFunctionABI;
    };
    testnetFaucetUSDC(args: {
        amount: bigint;
    }): {
        function: `0x${string}::test_trading::faucet_native_usdc`;
        functionArguments: bigint[];
    };
}

declare class MerkleClient {
    config: MerkleClientConfig;
    api: APIClient;
    wsapi: WSAPIClient;
    payloads: MerklePayloadBuilder;
    aptos: AptosHelpers;
    constructor(config: MerkleClientConfig);
}
interface MerkleClient extends APIClient, WSAPIClient, AptosHelpers {
}

declare const sleep: (ms: number) => Promise<unknown>;

declare const raise: (e?: string | Error) => never;

export { APIClient, Account, type AccountFeed, AptosHelpers, AptosObject, CancelOrderEvent, type Coin, Collection, Decimal, Decimals, type FeepayerResponse, type FundingInfo, type Hex, MerkleClient, MerkleClientConfig, MerkleConfig, MerklePayloadBuilder, type MoveStructId, type Order, PRECISION, PRICE_MAX, PRICE_MIN, PairInfo, type PairState, type PlaceOrderEvent, type Position, PositionEvent, type PriceFeed, type RawFeepayerResponse, RawOrder, RawPairInfoResponse, RawPairStateResponse, RawPosition, RawSummaryPair, RawSummaryResponse, RawTradeHistory, Royalty, type SimpleMap, type Summary, type SummaryCoin, type SummaryPair, type SummaryPrice, type TableHandle, type Timestamp, Token, type TradeHistory, type UpdateTPSLEvent, WSAPIClient, WSAPISession, type WSAPISessionConfig, abs, add, avg, calcAccFundingFeePerSize, calcAccRolloverFeePerCollateral, calcEntryByPaySize, calcExitFee, calcFundingFee, calcFundingInfo, calcFundingRate, calcMakerTakerFee, calcNewPrice, calcPnlInfo, calcPnlWithoutFee, calcPositionFees, calcPriceImpact, calcPriceImpactInfo, calcRolloverFee, calcSlippagePrice, cancelOrder, dec, dec0, div, fromNumber, getAllPairInfos, getAllPairStates, getOrders, getPairInfo, getPairState, getPositions, getSummary, getTradingHistory, getUsdcBalance, gt, gte, lt, lte, max, min, mul, neg, one, placeLimitOrder, placeMarketOrder, postFeepayer, raise, shift, sign, sleep, sub, testnetFaucetUSDC, toFixed, toNumber, undec, updateTPSL, zero };
